// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User Management
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id              String    @id @default(cuid())
  email           String    @unique
  username        String    @unique
  password        String?
  firstName       String?
  lastName        String?
  name            String?
  image           String?
  emailVerified   DateTime?
  bio             String?
  location        String?
  smokerType      String?
  experienceLevel String?   @default("beginner")
  joinedAt        DateTime  @default(now())
  lastActive      DateTime  @default(now())
  
  // Subscription
  stripeCustomerId     String?
  stripeSubscriptionId String?
  subscriptionStatus   String?  @default("free") // free, active, canceled, past_due
  subscriptionTier     String?  @default("free") // free, premium, pro
  subscriptionEnds     DateTime?
  adFree              Boolean  @default(false)
  
  // Creator Program
  creatorTier         CreatorTier @default(NONE)
  totalViews          Int         @default(0)
  totalEarnings       Float       @default(0)
  payoutThreshold     Float       @default(10) // Minimum $10 for payout
  stripeConnectId     String?     // For creator payouts

  // User content
  recipes       Recipe[]
  reviews       Review[]
  ratings       Rating[]
  comments      Comment[]
  favorites     Favorite[]
  follows       Follow[]  @relation("Follower")
  followers     Follow[]  @relation("Following")
  
  // Collections and planning
  collections   RecipeCollection[]
  mealPlans     MealPlan[]
  shoppingLists ShoppingList[]
  
  // Creator & Monetization
  recipeViews         RecipeView[]
  creatorPayouts      CreatorPayout[]
  liveEvents          LiveEvent[] @relation("EventHost")
  eventAttendees      LiveEventAttendee[]
  subscriptions       Subscription[]
  
  // Beta Testing
  betaTester          BetaTester? @relation("UserBetaTester")
  
  // Authentication
  accounts      Account[]
  sessions      Session[]

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}

// Recipe Management
model Recipe {
  id          String   @id @default(cuid())
  title       String
  description String
  slug        String   @unique
  
  // Author
  authorId    String
  author      User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // Recipe details
  prepTime    Int      // minutes
  cookTime    Int      // minutes
  totalTime   Int      // minutes
  servings    Int
  difficulty  Difficulty
  
  // BBQ specific
  smokingWood    String?
  smokerTemp     Int?     // Fahrenheit
  internalTemp   Int?     // Target internal temperature
  cookingMethod  CookingMethod
  sauce          String?  // BBQ sauce type/style
  seasoningRub   String?  // Seasoning mix or rub used
  
  // Content
  instructions   Instruction[]
  ingredients    RecipeIngredient[]
  images         RecipeImage[]
  tags           RecipeTag[]
  
  // Engagement
  reviews        Review[]
  ratings        Rating[]
  comments       Comment[]
  favorites      Favorite[]
  
  // Collections
  collections    RecipeCollectionItem[]
  mealPlanItems  MealPlanItem[]
  
  // Nutrition
  nutrition      Nutrition?
  
  // Metadata
  isPublished    Boolean  @default(false)
  isDraft        Boolean  @default(true)
  isPremium      Boolean  @default(false) // Requires premium to view full details
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  // Creator monetization
  views          RecipeView[]
  totalViews     Int      @default(0)
  premiumViews   Int      @default(0)
  
  // SEO
  metaTitle      String?
  metaDescription String?

  @@map("recipes")
}

model Ingredient {
  id          String @id @default(cuid())
  name        String @unique
  category    IngredientCategory
  
  // Nutrition data per 100g
  caloriesPerGram Float?
  proteinPerGram  Float?
  carbsPerGram    Float?
  fatPerGram      Float?
  
  recipes     RecipeIngredient[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("ingredients")
}

model RecipeIngredient {
  id           String     @id @default(cuid())
  recipeId     String
  recipe       Recipe     @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  ingredientId String
  ingredient   Ingredient @relation(fields: [ingredientId], references: [id])
  
  amount       Float
  unit         String
  preparation  String?    // "diced", "sliced", etc.
  optional     Boolean    @default(false)
  section      String?    // "For the rub", "For serving", etc.
  order        Int        @default(0)

  @@map("recipe_ingredients")
}

model Instruction {
  id          String @id @default(cuid())
  recipeId    String
  recipe      Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  
  stepNumber  Int
  title       String?
  description String
  temperature Int?     // Optional temperature for this step
  time        Int?     // Optional time in minutes for this step
  image       String?  // Optional image for this step
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([recipeId, stepNumber])
  @@map("instructions")
}

// Images and Media
model RecipeImage {
  id          String @id @default(cuid())
  recipeId    String
  recipe      Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  
  url         String
  alt         String?
  caption     String?
  isPrimary   Boolean @default(false)
  order       Int     @default(0)
  
  createdAt   DateTime @default(now())

  @@map("recipe_images")
}

// Social Features
model Review {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipeId  String
  recipe    Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  
  title     String?
  content   String
  rating    Int      // 1-5 stars
  wouldMakeAgain Boolean?
  
  // Modifications made
  modifications String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, recipeId])
  @@map("reviews")
}

model Rating {
  id       String @id @default(cuid())
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipeId String
  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  
  value    Int    // 1-5 stars
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, recipeId])
  @@map("ratings")
}

model Comment {
  id       String @id @default(cuid())
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipeId String
  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  
  content  String
  parentId String?
  parent   Comment? @relation("CommentReplies", fields: [parentId], references: [id])
  replies  Comment[] @relation("CommentReplies")
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("comments")
}

model Favorite {
  id       String @id @default(cuid())
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipeId String
  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())

  @@unique([userId, recipeId])
  @@map("favorites")
}

model Follow {
  id          String @id @default(cuid())
  followerId  String
  follower    User   @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  followingId String
  following   User   @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())

  @@unique([followerId, followingId])
  @@map("follows")
}

// Collections and Organization
model RecipeCollection {
  id          String @id @default(cuid())
  userId      String
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name        String
  description String?
  isPublic    Boolean @default(true)
  
  items       RecipeCollectionItem[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("recipe_collections")
}

model RecipeCollectionItem {
  id           String           @id @default(cuid())
  collectionId String
  collection   RecipeCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  recipeId     String
  recipe       Recipe           @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  
  order        Int              @default(0)
  addedAt      DateTime         @default(now())

  @@unique([collectionId, recipeId])
  @@map("recipe_collection_items")
}

// Meal Planning
model MealPlan {
  id        String         @id @default(cuid())
  userId    String
  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name      String
  startDate DateTime
  endDate   DateTime
  
  items     MealPlanItem[]
  
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  @@map("meal_plans")
}

model MealPlanItem {
  id         String   @id @default(cuid())
  mealPlanId String
  mealPlan   MealPlan @relation(fields: [mealPlanId], references: [id], onDelete: Cascade)
  recipeId   String
  recipe     Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  
  date       DateTime
  mealType   MealType
  servings   Int      @default(1)

  @@map("meal_plan_items")
}

model ShoppingList {
  id        String             @id @default(cuid())
  userId    String
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name      String
  items     ShoppingListItem[]
  
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  @@map("shopping_lists")
}

model ShoppingListItem {
  id             String       @id @default(cuid())
  shoppingListId String
  shoppingList   ShoppingList @relation(fields: [shoppingListId], references: [id], onDelete: Cascade)
  
  name           String
  amount         Float?
  unit           String?
  category       String?
  isCompleted    Boolean      @default(false)
  
  createdAt      DateTime     @default(now())

  @@map("shopping_list_items")
}

// Nutrition
model Nutrition {
  id             String @id @default(cuid())
  recipeId       String @unique
  recipe         Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  
  // Per serving
  calories       Int?
  protein        Float? // grams
  carbohydrates  Float? // grams
  fat            Float? // grams
  fiber          Float? // grams
  sugar          Float? // grams
  sodium         Float? // milligrams
  
  // Vitamins and minerals
  vitaminC       Float?
  calcium        Float?
  iron           Float?
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("nutrition")
}

// Tags and Categories
model Tag {
  id          String      @id @default(cuid())
  name        String      @unique
  category    TagCategory @default(GENERAL)
  
  recipes     RecipeTag[]
  
  createdAt   DateTime    @default(now())

  @@map("tags")
}

model RecipeTag {
  id       String @id @default(cuid())
  recipeId String
  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  tagId    String
  tag      Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([recipeId, tagId])
  @@map("recipe_tags")
}



// Enums
enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
  EXPERT
}

enum CookingMethod {
  SMOKING
  PELLET_SMOKER
  OFFSET_SMOKER
  GRILLING
  ROASTING
  BRAISING
  FRYING
  BAKING
  STEAMING
  BOILING
  OTHER
}

enum IngredientCategory {
  PROTEIN
  VEGETABLES
  FRUITS
  GRAINS
  DAIRY
  SPICES
  HERBS
  CONDIMENTS
  OILS
  SWEETENERS
  BEVERAGES
  OTHER
}

enum MealType {
  BREAKFAST
  LUNCH
  DINNER
  SNACK
  DESSERT
  APPETIZER
}

enum TagCategory {
  CUISINE
  DIETARY
  TECHNIQUE
  EQUIPMENT
  OCCASION
  SEASON
  GENERAL
}

// Subscription & Creator System

model Subscription {
  id                String   @id @default(cuid())
  userId            String
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  stripeSubscriptionId String @unique
  stripeCustomerId     String
  stripePriceId        String
  
  tier              SubscriptionTier
  status            SubscriptionStatus @default(ACTIVE)
  
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  canceledAt        DateTime?
  
  @@map("subscriptions")
}

model RecipeView {
  id         String   @id @default(cuid())
  recipeId   String
  recipe     Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  userId     String?
  user       User?    @relation(fields: [userId], references: [id])
  
  isPremiumUser Boolean @default(false)
  ipAddress     String?
  userAgent     String?
  
  viewedAt      DateTime @default(now())
  
  @@map("recipe_views")
}

model CreatorPayout {
  id            String        @id @default(cuid())
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  amount        Float
  period        String        // "2024-10" for October 2024
  payoutType    PayoutType
  
  stripeTransferId String?
  status           PayoutStatus @default(PENDING)
  
  // Breakdown
  recipeViews      Int    @default(0)
  liveEventRevenue Float  @default(0)
  bonusAmount      Float  @default(0)
  
  createdAt     DateTime @default(now())
  processedAt   DateTime?
  
  @@unique([userId, period])
  @@map("creator_payouts")
}

model LiveEvent {
  id          String   @id @default(cuid())
  hostId      String
  host        User     @relation("EventHost", fields: [hostId], references: [id], onDelete: Cascade)
  
  title       String
  description String?
  price       Float    // Price in dollars
  maxAttendees Int?
  
  scheduledFor DateTime
  duration     Int      // Minutes
  
  streamUrl    String?
  recordingUrl String?
  
  status       EventStatus @default(SCHEDULED)
  
  attendees    LiveEventAttendee[]
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@map("live_events")
}

model LiveEventAttendee {
  id        String    @id @default(cuid())
  eventId   String
  event     LiveEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  paidAmount Float
  stripePaymentIntentId String?
  
  joinedAt   DateTime?
  leftAt     DateTime?
  
  createdAt  DateTime @default(now())
  
  @@unique([eventId, userId])
  @@map("live_event_attendees")
}

// Enums for new system
enum SubscriptionTier {
  FREE
  PREMIUM
  PRO
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  UNPAID
  INCOMPLETE
}

enum CreatorTier {
  NONE
  BRONZE
  SILVER
  GOLD
  DIAMOND
}

enum PayoutType {
  RECIPE_VIEWS
  LIVE_EVENTS
  MONTHLY_BONUS
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum EventStatus {
  SCHEDULED
  LIVE
  COMPLETED
  CANCELED
}

// Beta Tester System
model BetaTester {
  id          String   @id @default(cuid())
  email       String   @unique
  firstName   String
  lastName    String
  phone       String?
  
  // Beta specific info
  experience  String   // beginner, intermediate, advanced, professional
  equipment   String   // what BBQ equipment they have
  interests   String   // comma-separated areas of interest
  motivation  String   // why they want to join beta
  
  // Status
  status      String @default("PENDING")
  inviteCode  String?    @unique
  joinedAt    DateTime   @default(now())
  
  // Chat
  chatMessages ChatMessage[]
  
  // User connection (when they create full account)
  userId      String?  @unique
  user        User?    @relation("UserBetaTester", fields: [userId], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("beta_testers")
}

model ChatMessage {
  id           String     @id @default(cuid())
  betaTesterId String
  betaTester   BetaTester @relation(fields: [betaTesterId], references: [id], onDelete: Cascade)
  
  message      String
  isFromAdmin  Boolean    @default(false)
  adminName    String?    // Name of admin who sent message
  
  createdAt    DateTime   @default(now())
  
  @@map("chat_messages")
}

// enum BetaStatus {
//   PENDING
//   APPROVED
//   WAITLIST
//   REJECTED
// }
